#!/bin/sh

USAGE="Usage: $(basename $0) <files to delete securely>: 'secure' rm, stores deleted files in a trash instead of deleting them directly, in order to give one more chance of retrieving them if necessary. See also: emptyTrash.sh"

TRASH_DEFAULT="$HOME/tmp/Trash"

if [ -z "$TRASH" ] ; then
	echo "Warning: \$TRASH no defined, assuming trash is $TRASH_DEFAULT"
	TRASH="$TRASH_DEFAULT"
fi


if [ ! -d "$TRASH" ] ; then
	echo "Warning: trash directory, $TRASH, does not exist; creating it."
	/bin/mkdir -p "$TRASH"
fi

echo

# Quoted $@ allows not to split parameters which contain for example spaces; $*
# allows to still have only one string (otherwise: too many arguments for the
# test)
#
if [ -n "$*" ] ; then

	echo "Secure deleting (moving to trash $TRASH):"
	echo "  $@"

	# This version finally preferred to the next one, which could not support
	# multiple filenames:

	for elem in "$@" ; do

		#echo "elem = ${elem}"

		actual_elem=$(basename ${elem} 2>/dev/null)
		#echo "actual_elem = ${actual_elem}"

		if [ -z "${actual_elem}" ] ; then

			echo "(uname to process element '${elem}', aborting)" 1>&2
			exit 17

		fi

		# File or (possibly dead) symbolic link:
		if [ -e "${elem}" ] || [ -h "${elem}" ] ; then

			# No need to have specific rights such as reading or writing in
			# order to move it (no chmod needed).

			if [ -e "${TRASH}/${actual_elem}" ] ; then

				new_elem="${actual_elem}-$(date +'%Y%m%d-%Hh%Mm%Ss')"
				new_full_elem="$TRASH/${new_elem}"

				# To provide a real unicity (otherwise a 'find' executing a srm
				# could remove in the same second a large number of different
				# files bearing the same name in that tree):
				#

				#echo "Testing trash target ${new_full_elem}"

				while [ -e "${new_full_elem}" ] ; do

					new_full_elem="${new_full_elem}x"

				done

				echo "Warning: element '${actual_elem}' was already existing in trash, storing it as '${new_full_elem}' instead." 1>&2

				/bin/mv -f "${elem}" "${new_full_elem}"

			else

				/bin/mv -f "${elem}" $TRASH

			fi

		else

			echo "(element '${elem}' not found, hence skipped)" 1>&2

		fi

	done

	# Better management of exotic filenames (ex: with spaces):
	#/bin/mv -f "$*" $TRASH

	# Better displayed in all cases:
	echo "Deleting finished"
	#echo

else

	echo "Error: no argument specified. $USAGE" 1>&2
	exit 5

fi
