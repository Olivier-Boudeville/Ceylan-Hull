#!/bin/sh

USAGE="Usage: $(basename $0) <files to delete securely>: 'secure' rm, stores deleted files in a trash instead of deleting them directly, in order to give one more chance of retrieving them if necessary. See also: emptyTrash.sh"

TRASH_DEFAULT="$HOME/tmp/Trash"

if [ -z "$TRASH" ] ; then
	echo "Warning: \$TRASH no defined, assuming trash is $TRASH_DEFAULT"
	TRASH="$TRASH_DEFAULT"
fi


if [ ! -d "$TRASH" ] ; then
	echo "Warning: trash directory, $TRASH, does not exist; creating it."
	/bin/mkdir -p "$TRASH"
fi

echo

# Quoted $@ allows not to split parameters which contain for example spaces; $*
# allows to still have only one string (otherwise: too many arguments for the
# test)
#
if [ -n "$*" ] ; then

	echo "Secure deleting (moving to trash $TRASH):"
	echo "  $@"

	# This version finally preferred to the next one, which could not support
	# multiple filenames:

	for elem in "$@" ; do

		#echo "elem = ${elem}"

		actual_elem=$(basename ${elem})
		#echo "actual_elem = ${actual_elem}"

		# File or symbolic link:
		if [ -e "${elem}" ] || [ -L "${elem}" ] ; then

			if [ -e "${TRASH}/${actual_elem}" ] || [ -L "${elem}" ] ; then

				new_elem=${actual_elem}-$(date +'%Y%m%d-%Hh%Mm%Ss')
				new_full_elem=$TRASH/${new_elem}
				echo "Warning: element '${actual_elem}' was already existing in trash, storing it as '$TRASH/${new_elem}' instead." 1>&2
				/bin/mv -f "$elem" $new_full_elem

			else

				/bin/mv -f "$elem" $TRASH

			fi

		else

			echo "(element '${elem}' not found, hence skipped)" 1>&2

		fi

	done

	# Better management of exotic filenames (ex: with spaces):
	#/bin/mv -f "$*" $TRASH

	# Better displayed in all cases:
	echo "Deleting finished"
	echo

else

	echo "Error: no argument specified. $USAGE" 1>&2
	exit 5

fi
