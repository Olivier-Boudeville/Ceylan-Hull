#!/bin/sh

USAGE="
$(basename $0): recursive grep in Erlang source files.
  Usage: $(basename $0) [-v|--verbose] [-q|--quiet] [-i|--insensitive] <Expression to be found in files>
  Options:
	-v or --verbose: be specifically verbose
	-q or --quiet: be specifically quiet, just listing matches
	-f or --filenames-only: display only filenames, not also the matched patterns, and if there are multiple matches in the same file, its filename will be output only once (implies quiet)
	-i or --insensitive: perform case-insensitive searches in the content of files, and also in the searched Erlang filenames
  Example: $(basename $0) -i 'list_to_form('"


find=$(which find | grep -v ridiculously 2>/dev/null)
grep=$(which grep | grep -v ridiculously 2>/dev/null)

#echo "grep = ${grep}"
#echo "find = ${find}"


if [ ! -x "${grep}" ] ; then
	echo "Error, no executable grep found." 1>&2
	exit 5
fi


if [ ! -x "${find}" ] ; then
	echo "Error, no executable find found." 1>&2
	exit 6
fi


# Both are false by default:
verbose=1
quiet=1

insensitive_opt=""
filenames_only=1


# A useless file to ensure grep always has multiple files to scan.
# Done to force grep to display the filename (otherwise it will not)
# No need to create it, however.
#
force_multi_files="$HOME/.ergrep.toDelete.tmp"

name_opt="-name"

if [ $# -eq 0 ] ; then
	echo "Error, too few parameters. $USAGE" 1>&2
	exit 1
fi


if [ $# -ge 4 ] ; then
	echo "Error, too many parameters ($*). $USAGE" 1>&2
	exit 2
fi



# Read all known options:

token_eaten=0

while [ $token_eaten -eq 0 ] ; do

	read_parameter="$1"
	#echo "read_parameter = $read_parameter"

	token_eaten=1

	if [ "$read_parameter" = "--verbose" -o "$read_parameter" = "-v" ] ; then
		verbose=0
		quiet=1
		echo "Verbose mode activated."
		token_eaten=0
	fi


	if [ "$read_parameter" = "--quiet" -o "$read_parameter" = "-q" ] ; then
		verbose=1
		quiet=0
		#echo "Quiet mode activated."
		token_eaten=0
	fi

	if [ "$read_parameter" = "--filenames-only" -o "$read_parameter" = "-f" ] ; then
		verbose=1
		quiet=0
		filenames_only=0
		[ $quiet -eq 0 ] || echo "Only filenames will be written, not found patterns."
		token_eaten=0
	fi


	if [ "$read_parameter" = "--insensitive" -o "$read_parameter" = "-i" ] ;
	then
		insensitive_opt="-i"
		name_opt="-iname"
		[ $quiet -eq 0 ] || echo "Case-insensitive mode activated."
		token_eaten=0
	fi

	if [ -n "$read_parameter" ] ; then
		shift
	fi

done

if [ -z "$read_parameter" ] ; then
	echo "Error, too few parameters. $USAGE" 1>&2
	exit 3
fi


searched_expression="$read_parameter"
#echo "searched_expression = $searched_expression"


# Then check no parameter remains:

if [ $# -ge 1 ] ; then
	echo "Error, too many parameters ($*). $USAGE" 1>&2
	exit 4
fi


base_grep_opt="--color"

# NEVER surround these single quotes by double ones:
filter_erl='*.?rl'

filter_expr="${name_opt} ${filter_erl}"

if [ $verbose -eq 0 ] ; then

	echo "Will search in following files:"
	$find . ${filter_expr}

fi



[ $quiet -eq 0 ] || echo "
	Recursive grep for expression <${searched_expression}> in all Erlang files:
	"

if [ $filenames_only -eq 1 ] ; then

	$find . ${filter_expr} -exec $grep ${base_grep_opt} ${insensitive_opt} "${searched_expression}" '{}' $force_multi_files ';' 2>/dev/null

else

	$find . ${filter_expr} -exec $grep ${base_grep_opt} ${insensitive_opt} "${searched_expression}" '{}' $force_multi_files ';' 2>/dev/null | sed 's|:.*$||1' | uniq

fi

[ $quiet -eq 0 ] || echo "
End of search."
